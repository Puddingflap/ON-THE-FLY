<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>ASTER OID</title>
  <style>
    :root{
      --bg:#070b14; /* deep space */
      --fg:#e8f0ff;
      --accent:#6ee7ff; /* neon blue */
      --accent2:#ffcc6e; /* warm highlight */
      --danger:#ff6e6e;
      --muted:#6b7280;
      --shadow:0 10px 30px rgba(0,0,0,.35);
    }
    html,body{height:100%;margin:0}
    body{
      background: radial-gradient(1200px 800px at 70% 20%, rgba(110,231,255,.06), transparent), var(--bg);
      color:var(--fg);
      font-family: system-ui, sans-serif;
      overflow:hidden;
    }
    #wrap{position:fixed; inset:0; display:grid; place-items:center}
    canvas{ width: min(100vw, 100vh*0.5625); height: min(100vh, 100vw/0.5625); max-width:100vw; max-height:100vh; box-shadow: var(--shadow); border-radius: 18px; background: transparent; }

    /* HUD */
    .hud{position:fixed; inset:0; pointer-events:none; display:flex; align-items:center; justify-content:center;}
    .panel{pointer-events:auto; position:absolute; top:24px; left:50%; transform:translateX(-50%); background: rgba(8,12,22,.6); border:1px solid rgba(255,255,255,.08); backdrop-filter: blur(6px); padding:10px 14px; border-radius:14px; display:flex; gap:18px; align-items:center}
    .panel .pill{background:rgba(255,255,255,.08); padding:6px 10px; border-radius:999px; font-weight:700; letter-spacing:.3px}
    .panel .sep{opacity:.3}
    .btn{
      pointer-events:auto; position:absolute; bottom:24px; left:50%; transform:translateX(-50%);
      background:linear-gradient(180deg, rgba(110,231,255,.18), rgba(110,231,255,.12));
      border:1px solid rgba(110,231,255,.4); color:var(--fg); font-weight:700; letter-spacing:.3px;
      padding:12px 18px; border-radius:14px; box-shadow: var(--shadow); text-decoration:none;
    }
    .hint{position:absolute; bottom:86px; left:50%; transform:translateX(-50%); color:var(--muted); font-size:14px}
    .title{position:absolute; top:50%; left:50%; transform:translate(-50%, -60%); text-align:center}
    h1{margin:0 0 6px 0; font-size: clamp(28px, 6vw, 48px)}
    .subtitle{opacity:.75}
    .toast{position:absolute; top:14px; right:14px; background:rgba(255,110,110,.12); border:1px solid rgba(255,110,110,.35); color:#ffd3d3; padding:8px 12px; border-radius:12px; font-size:12px}
    a,button{cursor:pointer}
    @supports not (backdrop-filter: blur(6px)) {
      .panel { background: rgba(8,12,22,.8); }
    }

    /* Leaderboard HUD */
    .leaderboard-panel {
      pointer-events:auto; position:absolute; top:50%; left:50%; transform:translate(-50%, -50%);
      background: rgba(8,12,22,.85); border:1px solid rgba(255,255,255,.08); backdrop-filter: blur(6px);
      padding:20px; border-radius:14px; max-width:80%; text-align:center; display:none;
    }
    .leaderboard-panel h2 { margin:0 0 12px; font-size:24px; }
    .leaderboard-panel ul { list-style:none; padding:0; margin:0 0 16px; }
    .leaderboard-panel li { padding:4px 0; font-size:16px; }
    .leaderboard-panel .close-btn { background:var(--accent); border:none; color:var(--bg); padding:8px 16px; border-radius:8px; cursor:pointer; }
    .name-input { background:rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.2); color:var(--fg); padding:8px; border-radius:8px; text-transform:uppercase; max-width:60px; text-align:center; font-weight:bold; }
    .name-input:focus { outline:none; border-color:var(--accent); }

    /* Stage hint */
    .stage-hint {
      position:absolute; top:50%; left:50%; transform:translate(-50%, -50%);
      background: rgba(8,12,22,.8);
      padding:10px 20px; border-radius:10px; color:var(--accent); font-size:18px; opacity:0;
      transition: opacity 0.5s;
    }

    /* ===== INTRO OVERLAY ===== */
    .intro {
      position:fixed; inset:0; z-index:9999;
      display:grid; grid-template-rows: 1fr auto; place-items:center;
      background: radial-gradient(1200px 600px at 50% 30%, rgba(110,231,255,0.08), transparent),
                  radial-gradient(800px 400px at 80% 70%, rgba(255, 204, 110, 0.10), transparent),
                  var(--bg);
      user-select:none;
    }
    .intro .face {
      position:fixed; left:50%; top:50%;
      transform: translate(-50%, -50%) scale(1) rotate(0deg);
      width:min(80vmin, 540px); aspect-ratio:1/1;
      background:url('cz-droid.png') center/contain no-repeat;
      filter: drop-shadow(0 30px 50px rgba(0,0,0,0.45));
      will-change: transform;
      animation: bob 4.8s ease-in-out infinite, tilt 7s ease-in-out infinite, spin 28s linear infinite;
    }
    .intro .cta { margin-bottom: 28px; text-align:center; }
    .intro .cta .start { 
      appearance:none; border:0; padding:14px 22px; border-radius:999px;
      font-size: clamp(16px, 2.6vmin, 20px); font-weight:700; cursor:pointer; color:#0b1220;
      background: linear-gradient(135deg, var(--accent), var(--accent2));
      box-shadow: 0 10px 24px rgba(110,231,255,0.25), 0 6px 16px rgba(255,204,110,0.18);
    }
    .intro .hint { color:var(--muted); margin-top:10px; }

    .hidden { display:none !important; }

    @keyframes bob { 0%,100%{ transform:translate(-50%, -50%) scale(1) } 50%{ transform:translate(calc(-50%), calc(-50% - 10px)) scale(1) } }
    @keyframes tilt { 0%,100%{ } 50%{ } } /* subtiel, echte tilt doen we via rotate() in JS indien gewenst */
    @keyframes spin { to { transform: translate(-50%, -50%) scale(1) rotate(360deg); } }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game" width="1280" height="720" aria-label="ASTER OID"></canvas>
  </div>

  <!-- HUD -->
  <div class="hud" aria-live="polite">
    <div class="panel" id="scorePanel" hidden>
      <span class="pill">Score: <span id="score">0</span></span>
      <span class="sep">â€¢</span>
      <span class="pill">Best: <span id="best">0</span></span>
      <span class="sep">â€¢</span>
      <span class="pill">Logos: <span id="logosCollected">0</span></span>
    </div>
    <div class="title" id="title">
      <h1>ðŸ’« ASTER OID</h1>
      <div class="subtitle">Tap/Click of <strong>SPATIE</strong> om te boosten</div>
    </div>
    <div class="hint" id="hint">Tip: blijf gecentreerd, lees de gaps, boost op het laatste moment.</div>
    <button class="btn" id="startBtn" aria-label="Start game (of druk op spatie)">Start</button>
    <div class="toast" id="pauseToast" hidden>Game gepauzeerd (tab niet actief)</div>
    <div class="leaderboard-panel" id="leaderboardPanel">
      <h2>Leaderboard (Top 10)</h2>
      <ul id="leaderboardList"></ul>
      <div id="nameInputSection" style="margin-bottom:16px; display:none;">
        <label for="nameInput">Initialen (max 3):</label><br>
        <input type="text" id="nameInput" class="name-input" maxlength="3" placeholder="ABC">
        <button id="submitName" class="close-btn" style="margin-left:8px;">Save</button>
      </div>
      <button id="closeLeaderboard" class="close-btn">Close</button>
    </div>
    <div id="stageHint" class="stage-hint"></div>
  </div>

  <!-- INTRO OVERLAY -->
  <div id="intro" class="intro" aria-hidden="false">
    <div id="introFace" class="face" role="img" aria-label="CZ Droid"></div>
    <div class="cta">
      <button id="introStart" class="start" type="button">Start</button>
      <div class="hint">Druk op <b>spatie</b> of klik om te beginnen (muziek start na je eerste interactie).</div>
    </div>
  </div>

  <audio id="introMusic" src="intro.mp3" preload="auto" loop></audio>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  const W0 = canvas.width, H0 = canvas.height;
  function resize() {
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.round(rect.width * DPR);
    canvas.height = Math.round(rect.height * DPR);
    scale = canvas.width / W0;
  }
  let scale = 1; resize();
  let resizeTimeout;
  window.addEventListener('resize', () => { clearTimeout(resizeTimeout); resizeTimeout = setTimeout(resize, 100); });

  // ===== INTRO logic =====
  const intro = document.getElementById('intro');
  const introFace = document.getElementById('introFace');
  const introStart = document.getElementById('introStart');
  const music = document.getElementById('introMusic');
  let hasPrimedAudio = false, introSequenceStarted = false;

  function primeAudio() {
    if (hasPrimedAudio) return;
    hasPrimedAudio = true;
    music.volume = 0.85;
    music.currentTime = 0;
    music.play().catch(() => { hasPrimedAudio = false; });
  }
  ['pointerdown','keydown'].forEach(evt => {
    window.addEventListener(evt, (e) => {
      if (e.type === 'keydown' && e.code === 'Space') e.preventDefault();
      primeAudio();
    }, { passive:false });
  });

  function fadeOutAudio(audioEl, ms = 1500) {
    const steps = 30, stepTime = ms / steps;
    const startVol = audioEl.volume;
    let i = 0;
    const t = setInterval(() => {
      i++;
      audioEl.volume = Math.max(0, startVol * (1 - i/steps));
      if (i >= steps) { clearInterval(t); audioEl.pause(); audioEl.currentTime = 0; audioEl.volume = startVol; }
    }, stepTime);
  }

  function startIntroSequence() {
    if (introSequenceStarted) return;
    introSequenceStarted = true;

    // Bereken doelpositie (center van speler) in CSS pixels
    const rect = canvas.getBoundingClientRect();
    const targetX = rect.left + player.x; // mapping 1 css px â‰ˆ 1 game unit
    const targetY = rect.top + player.y;

    // Huidig middelpunt (viewport center)
    const vpX = window.innerWidth / 2;
    const vpY = window.innerHeight / 2;

    // Doelgrootte: diameter van sprite = 2 * r (in CSS px)
    const targetSize = player.r * 2;
    const faceRect = introFace.getBoundingClientRect();
    const startSize = faceRect.width;
    const scaleTo = Math.max(0.001, targetSize / startSize);

    // Delta verplaatsing
    const dx = targetX - vpX;
    const dy = targetY - vpY;

    // Stop bob/spin animatie voor strakke zoom
    introFace.style.animation = 'none';

    // Smooth transform naar doelpositie en schaal
    introFace.style.transition = 'transform 2s cubic-bezier(.2,.8,.2,1)';
    introFace.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px)) scale(${scaleTo}) rotate(0deg)`;

    // Na animatie: intro weg, muziek faden, game starten
    setTimeout(() => {
      fadeOutAudio(music, 1200);
      intro.classList.add('hidden');
      // Start via de bestaande game-flow (boost -> startGame)
      requestAnimationFrame(() => boost());
    }, 2000);
  }

  introStart.addEventListener('click', startIntroSequence);
  window.addEventListener('keydown', (e) => { if (e.code === 'Space' && !intro.classList.contains('hidden')) { e.preventDefault(); startIntroSequence(); } });

  // ====== GAME ======
  const G = 2600;
  const FLAP_VY = -850;
  const MAX_DROP = 1200;
  let PIPE_GAP = 290; // fixed
  const PIPE_W = 120;
  let PIPE_SPACING = 420;
  let SCROLL_SPEED = 180;
  const ACCEL = 0; // disabled
  const MARGIN_TOP = 60;

  // Speler-startpositie
  const AST = { r: 28, x: 200, y: 300 };

  // Sprite image (gezicht) voor speler
  const SPRITE_IMG = new Image();
  SPRITE_IMG.src = 'cz-droid.png';
  let spriteReady = false;
  SPRITE_IMG.onload = () => { spriteReady = true; };

  let state = 'start';
  let score = 0, best = +(localStorage.getItem('aster-oid-best')||0);
  let tPrev = 0, speed = SCROLL_SPEED, paused = false;
  let canFlap = true;
  let leaderboardActive = false;
  let currentStage = 1;
  let pipesPassed = 0;
  let logosCollected = 0;

  const ui = {
    scorePanel: document.getElementById('scorePanel'),
    score: document.getElementById('score'),
    best: document.getElementById('best'),
    logosCollected: document.getElementById('logosCollected'),
    startBtn: document.getElementById('startBtn'),
    title: document.getElementById('title'),
    hint: document.getElementById('hint'),
    pauseToast: document.getElementById('pauseToast'),
    leaderboardPanel: document.getElementById('leaderboardPanel'),
    leaderboardList: document.getElementById('leaderboardList'),
    nameInputSection: document.getElementById('nameInputSection'),
    nameInput: document.getElementById('nameInput'),
    submitName: document.getElementById('submitName'),
    closeLeaderboard: document.getElementById('closeLeaderboard'),
    stageHint: document.getElementById('stageHint'),
  };
  ui.best.textContent = best;
  ui.logosCollected.textContent = logosCollected;

  const LEADERBOARD_KEY = 'aster-oid-leaderboard';
  let leaderboard = JSON.parse(localStorage.getItem(LEADERBOARD_KEY)) || [];
  function saveLeaderboard() {
    leaderboard.sort((a, b) => b.score - a.score);
    leaderboard = leaderboard.slice(0, 10);
    localStorage.setItem(LEADERBOARD_KEY, JSON.stringify(leaderboard));
  }
  function showLeaderboard(showInput = false) {
    ui.leaderboardList.innerHTML = '';
    leaderboard.forEach((entry, i) => {
      const li = document.createElement('li');
      li.textContent = `${i + 1}. ${entry.name} - ${entry.score}`;
      ui.leaderboardList.appendChild(li);
    });
    ui.nameInputSection.style.display = showInput ? '' : 'none';
    ui.leaderboardPanel.style.display = 'block';
    leaderboardActive = true;
    if (showInput) ui.nameInput.focus();
  }
  function handleNameSubmit() {
    const name = ui.nameInput.value.trim().toUpperCase().slice(0, 3) || 'AAA';
    leaderboard.push({ name, score });
    saveLeaderboard();
    ui.leaderboardPanel.style.display = 'none';
    leaderboardActive = false;
    ui.nameInput.value = '';
  }
  ui.submitName.addEventListener('click', handleNameSubmit);
  ui.nameInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') handleNameSubmit(); });
  ui.closeLeaderboard.addEventListener('click', () => { ui.leaderboardPanel.style.display = 'none'; leaderboardActive = false; });
  window.addEventListener('keydown', (e) => { if (e.key === 'Escape' && leaderboardActive) { ui.leaderboardPanel.style.display = 'none'; leaderboardActive = false; } });

  function setUI(){
    const isStartOrDead = state === 'start' || state === 'dead';
    // Intro bedekt de start-UI, maar we laten het onderliggend gedrag ongewijzigd
    ui.title.style.display = isStartOrDead ? '' : 'none';
    ui.hint.style.display = isStartOrDead ? '' : 'none';
    ui.startBtn.style.display = isStartOrDead ? '' : 'none';
    ui.scorePanel.hidden = state !== 'playing' && state !== 'dead';
  }

  function showStageHint(message) {
    ui.stageHint.textContent = message;
    ui.stageHint.style.opacity = 1;
    setTimeout(() => { ui.stageHint.style.opacity = 0; }, 2000);
  }

  const stars = Array.from({length: 160}, () => ({
    x: Math.random()*canvas.width,
    y: Math.random()*canvas.height,
    z: 0.3 + Math.random()*0.7,
    r: 0.6 + Math.random()*1.8,
  }));

  const player = {
    x: AST.x, y: AST.y, r: AST.r,
    vy: 0,
    rot: 0,
    flap(){
      if (!canFlap) return;
      this.vy = FLAP_VY; flash(0.17);
      canFlap = false; setTimeout(() => canFlap = true, 150);
    },
    update(dt){
      this.vy = Math.min(this.vy + G*dt, MAX_DROP);
      this.y += this.vy * dt;
      this.rot = Math.max(-0.6, Math.min(0.9, this.vy/900));
    },
    draw(){
      ctx.save();
      ctx.translate(this.x*DPR, this.y*DPR);
      ctx.rotate(this.rot);
      const size = this.r * 2 * DPR;
      if (spriteReady) {
        // Teken cz-droid.png gecentreerd op speler
        ctx.drawImage(SPRITE_IMG, -size/2, -size/2, size, size);
      } else {
        // Fallback: eenvoudige cirkel
        ctx.fillStyle = '#b57f3a';
        ctx.beginPath(); ctx.arc(0,0,this.r*DPR,0,Math.PI*2); ctx.fill();
      }
      // Thruster effect bij stijgen
      if (this.vy < -50) {
        ctx.save();
        ctx.translate(-this.r*DPR*0.9, 0);
        ctx.rotate(-Math.PI / 2);
        const len = Math.min(60, 30 + (-this.vy) * 0.06);
        const grad = ctx.createLinearGradient(0, 0, 0, len);
        grad.addColorStop(0, 'rgba(110,231,255,0.85)');
        grad.addColorStop(1, 'rgba(110,231,255,0)');
        ctx.fillStyle = grad;
        ctx.beginPath(); ctx.moveTo(0, -6); ctx.lineTo(0, 6); ctx.lineTo(len, 0); ctx.closePath(); ctx.fill();
        ctx.restore();
      }
      ctx.restore();
    }
  };

  const pipes = [];
  const coins = []; // 'logos'
  const explosions = [];
  const LOGO_CHANCE = 0.2;
  const LOGO_SIZE = 20;
  const LOGO_GAP = 100;
  const LOGO_SCORE_BONUS = 5;

  function resetPipes() {
    pipes.length = 0;
    coins.length = 0;
    explosions.length = 0;
    pipesPassed = 0;
    const count = 8;
    for (let i = 0; i < count; i++) addObstacle(i);
  }

  function addObstacle(i) {
    const lastX = pipes.length + coins.length ? Math.max(
      pipes.length ? pipes[pipes.length - 1].x : -Infinity,
      coins.length ? coins[coins.length - 1].x : -Infinity
    ) : canvas.width / DPR + 300;
    const x = lastX + PIPE_SPACING;
    if (Math.random() < LOGO_CHANCE) {
      const gapY = MARGIN_TOP + Math.random() * (canvas.height / DPR - 2 * MARGIN_TOP - LOGO_GAP);
      coins.push({ x, y: gapY + LOGO_GAP / 2, r: LOGO_SIZE, collected: false });
      PIPE_SPACING += LOGO_GAP;
    } else {
      const gapY = MARGIN_TOP + Math.random() * (canvas.height / DPR - 2 * MARGIN_TOP - PIPE_GAP);
      pipes.push({ x, gapY, passed: false });
      PIPE_SPACING = 420;
    }
  }

  let flashT = 0;
  function flash(d) { flashT = Math.max(flashT, d); }
  function addExplosion(x, y) { explosions.push({ x, y, startTime: performance.now(), duration: 500, maxRadius: 50 }); }

  function boost() {
    if (leaderboardActive) return;
    if (state === 'start') { startGame(); }
    else if (state === 'dead') { restart(); }
    else if (state === 'playing') { player.flap(); }
  }
  window.addEventListener('keydown', e => {
    if (['Space', 'ArrowUp', 'KeyW'].includes(e.code)) { e.preventDefault(); boost(); }
    if (e.code === 'KeyR') restart();
  });
  window.addEventListener('pointerdown', e => { if (e.target === canvas || e.target === document.body) boost(); });
  ui.startBtn.addEventListener('click', boost);

  document.addEventListener('visibilitychange', () => {
    paused = document.hidden;
    ui.pauseToast.hidden = !paused;
  });

  function startGame() {
    state = 'playing';
    score = 0; speed = SCROLL_SPEED; tPrev = 0; currentStage = 1;
    player.x = AST.x; player.y = AST.y; player.vy = 0;
    PIPE_GAP = 290;
    logosCollected = 0;
    ui.logosCollected.textContent = logosCollected;
    resetPipes();
    setUI();
    showStageHint('Stage 1: Orbit Entry');
  }
  function gameOver() {
    state = 'dead';
    best = Math.max(best, score); localStorage.setItem('aster-oid-best', best); ui.best.textContent = best;
    ui.title.querySelector('h1').innerHTML = 'ðŸ’¥ Game Over';
    ui.hint.textContent = 'Druk R of klik om opnieuw te spelen';
    ui.startBtn.textContent = 'Restart';
    setUI();
    const minTop10 = leaderboard[9] ? leaderboard[9].score : 0;
    if (score > minTop10) showLeaderboard(true);
  }
  function restart() {
    ui.title.querySelector('h1').innerHTML = 'ðŸ’« ASTER OID';
    ui.startBtn.textContent = 'Start';
    startGame();
  }

  function update(dt) {
    // Stages: elke 10 pipes naar volgende stage
    if (pipesPassed >= 10 && currentStage < 10) {
      currentStage++;
      speed = SCROLL_SPEED + (currentStage - 1) * 10;
      pipesPassed = 0;
      switch (currentStage) {
        case 2: showStageHint('Stage 2: Meme Belt'); break;
        case 3: showStageHint('Stage 3: Shitcoin Storm'); break;
        case 4: showStageHint('Stage 4: Liquidity Void'); break;
        case 5: showStageHint('Stage 5: Market Crash Zone'); break;
        case 6: showStageHint('Stage 6: CZâ€™s Wrath'); break;
        case 7: showStageHint('Stage 7: Bear Market Abyss'); break;
        case 8: showStageHint('Stage 8: Asteroid Season'); break;
        case 9: showStageHint('Stage 9: To the Moon'); break;
        case 10: showStageHint('Stage 10: Final Impact'); break;
      }
      resetPipes();
    }

    speed += ACCEL * dt * 100;
    player.update(dt);
    const move = speed * dt;
    for (const p of pipes) { p.x -= move; }
    for (let i = 0; i < pipes.length; i++) {
      const p = pipes[i];
      if (!p.passed && player.x > p.x + PIPE_W / 2) {
        p.passed = true;
        score++; pipesPassed++;
        ui.score.textContent = score;
      }
      if (p.x + PIPE_W < -80) { pipes.shift(); addObstacle(1); i--; }
    }
    for (let i = 0; i < coins.length; i++) {
      const c = coins[i];
      c.x -= move;
      const dx = player.x - c.x;
      const dy = player.y - c.y;
      const distance = Math.hypot(dx, dy);
      if (distance < player.r + c.r && !c.collected) {
        c.collected = true;
        score += LOGO_SCORE_BONUS;
        logosCollected++; ui.logosCollected.textContent = logosCollected; ui.score.textContent = score;
        addExplosion(c.x, c.y);
      }
      if (c.x + c.r < -80) { coins.splice(i, 1); i--; }
    }
    if (player.y - player.r < 0 || player.y + player.r > canvas.height / DPR) return gameOver();
    for (const p of pipes) {
      const inX = player.x + player.r > p.x && player.x - player.r < p.x + PIPE_W;
      if (inX) {
        if (player.y - player.r < p.gapY || player.y + player.r > p.gapY + PIPE_GAP) return gameOver();
      }
    }
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const g = ctx.createLinearGradient(0, 0, 0, canvas.height);
    g.addColorStop(0, '#091224'); g.addColorStop(1, '#05070f');
    ctx.fillStyle = g; ctx.fillRect(0, 0, canvas.width, canvas.height);

    for (const s of stars) {
      s.x -= (speed * s.z * 0.08) * (1 / 60) * DPR;
      if (s.x < -2) { s.x = canvas.width + Math.random() * 40; s.y = Math.random() * canvas.height; s.z = 0.3 + Math.random() * 0.7; }
      ctx.globalAlpha = 0.5 + s.z * 0.5;
      ctx.beginPath(); ctx.arc(s.x, s.y, s.r * DPR, 0, Math.PI * 2); ctx.fillStyle = '#e8f0ff'; ctx.fill();
      if (Math.random() < 0.003) { ctx.globalAlpha = 0.9; ctx.fillRect(s.x - 0.5, s.y - 0.5, 1, 1); }
    }
    ctx.globalAlpha = 1;

    for (const p of pipes) {
      const x = p.x * DPR; const w = PIPE_W * DPR; const gapY = p.gapY * DPR; const gapH = PIPE_GAP * DPR;
      drawRockColumn(x, 0, w, gapY - 0, true);
      drawRockColumn(x, gapY + gapH, w, canvas.height - (gapY + gapH), false);
      ctx.strokeStyle = 'rgba(110,231,255,0.18)'; ctx.lineWidth = 4 * DPR; ctx.beginPath(); ctx.moveTo(x, gapY); ctx.lineTo(x, gapY + gapH); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(x + w, gapY); ctx.lineTo(x + w, gapY + gapH); ctx.stroke();
    }

    // Logos
    for (const c of coins) {
      if (!c.collected) {
        ctx.save(); ctx.translate(c.x * DPR, c.y * DPR);
        ctx.beginPath();
        ctx.moveTo(-c.r * DPR * 0.5, -c.r * DPR);
        ctx.lineTo(c.r * DPR * 0.5, -c.r * DPR);
        ctx.lineTo(c.r * DPR, c.r * DPR);
        ctx.lineTo(-c.r * DPR, c.r * DPR);
        ctx.closePath();
        ctx.fillStyle = '#f0f'; ctx.fill();
        ctx.strokeStyle = '#fff'; ctx.lineWidth = 2 * DPR; ctx.stroke();
        ctx.restore();
      }
    }

    // Explosions
    const now = performance.now();
    for (let i = explosions.length - 1; i >= 0; i--) {
      const e = explosions[i];
      const elapsed = (now - e.startTime) / e.duration;
      if (elapsed >= 1) explosions.splice(i, 1);
      else {
        const radius = e.maxRadius * elapsed;
        const alpha = 1 - elapsed;
        ctx.beginPath();
        ctx.arc(e.x * DPR, e.y * DPR, radius * DPR, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255, 165, 0, ${alpha})`;
        ctx.fill();
      }
    }

    player.draw();

    if (flashT > 0) {
      ctx.fillStyle = `rgba(255,255,255,${flashT})`; ctx.fillRect(0, 0, canvas.width, canvas.height); flashT = Math.max(0, flashT - 0.04);
    }
  }

  function drawRockColumn(x, y, w, h, fromTop) {
    ctx.save();
    ctx.beginPath();
    const step = 32 * DPR; const rough = 18 * DPR; const start = y; const end = y + h;
    ctx.moveTo(x, start);
    for (let yy = start; yy <= end; yy += step) {
      const off = (Math.sin(yy * 0.03) * 0.5 +
